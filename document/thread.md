​	LoRaWAN网关主要通过七个线程实现（包括主线程），为了网关可以支持MQTT设备连接，这里先建了一个线程---thread_elora，可以通过emqx.ini配置文件中选择是否启用该线程。

**1、主线程**

​	主线程首先会设置信号、初始化变量并解析命令行参数，然后启动 GPS、集中器，并建立 socket 连接。接下来创建各个子线程，在调用主循环，进行信息统计。最后等待各个子线程结束再退出。

**2、thread_up**

​	该线程用于处理上行数据包并将其发送到服务器。首先，通过 lgw_receive 函数从LoRa网关的射频芯片中获取接收到的数据包，并将其存储在 rxpt 数组中。检测是否有数据或者统计报告需要发送，如果没有则休眠一段时间。接下来初始化上行数据包的缓冲区，并填充固定字段（协议版本、Token、网关MAC地址）。然后遍历接收到的数据包数组，将每个数据包的信息（如时间戳、频率、信道、RSSI、SNR、数据负载等）序列化为JSON格式，并追加到上行数据包缓冲区。最后，将数据包封装成PUSH_DATA消息，通过UDP发送到服务器，接收服务器返回的PUSH_ACK消息，并进行相应处理。

**3、thread_down**

​	该线程用于从服务器接收下行数据包（PULL_RESP packet），将其传至JIT队列。它通常是一个无限循环，持续运行以不断接收服务器的下行数据包。通常使用阻塞式的 recv 函数，等待数据包到达。接收到PULL_RESP数据包后， 会对数据包进行解析。具体来说，它会解析JSON格式的数据，提取出下行数据的各个字段，例如目标节点地址、发送频率、功率等。解析完成后，thread_down 将提取的数据存入一个 txpt 结构体中。这个结构体包含了下行消息的所有必要信息，包括要发送的payload数据、发送时间、频率、功率等。 为了确认数据包已成功接收和处理，它会向服务器发送一个TX_ACK数据包。thread_down会将填充好的 txpkt 结构体放入JIT队列中。JIT队列管理所有待发送的下行数据包，确保它们能够在正确的时间发送，以避免冲突和干扰。

**4、thread_jit**

​	该线程通常也是一个无限循环，持续运行以不断检查和处理JIT队列中的数据包。在循环中，thread_jit 会定期获取当前的系统时间。这是为了确保可以正确地调度数据包的发送时间。它会检查JIT队列中是否有待发送的数据包。如果队列为空，它会休眠一段时间，然后继续循环。如果JIT队列中有数据包，thread_jit 会提取出最早需要发送的数据包，并检查该数据包的发送时间是否已到。如果发送时间未到，它会计算需要等待的时间，并在此期间休眠。如果发送时间已到，它会立即准备发送数据包。当数据包的发送时间到达时，thread_jit会调用 lgw_send 函数，将数据包发送到LoRa集中器。最后检查 lgw_send 函数的返回值，以确定发送是否成功。

**5、thread_gps**

​	该线程用于从串口读取GPS数据，并解析NMEA或UBX格式的信息。首先调用 read 函数从串口读取数据。然后扫描缓冲区，如果发现UBX同步字符则调用 lgw_parse_ubx 函数解析UBX数据。如果发现NMEA同步字符则寻找NMEA结束标志，如果找到就调用    lgw_parse_nmea 函数解析NMEA数据。最后，处理已解析的帧。

**6、thread_valid**

​	该线程用于验证GPS时间参考并管理XTAL（晶体）校正。该线程每一秒执行一次任务，计算从上次更新到现在的时间差，如果在有效范围内，则将GPS参考标记为有效。如果本地GPS参考无效，将XTAL校正标记为无效。如果本地GPS参考有效，将XTAL校正标记为有效。

**7、thread_spectral_scan**

​	该线程用于执行频谱扫描的线程。它会按照指定的时间进行等待，然后遍历所有RF链路，如果某个链路正在传输则跳过频谱扫描，输出相关信息并退出当前循环。如果没有正在传输的数据调用 lgw_spectral_scan_start 函数开始频谱扫描。如果频谱扫描成功启动，则进入等待状态，直到扫描完成或超时。最后，处理扫描结果并更新频率。

**8、thread_eLoRa**

​	LoRaWAN网关源码没有该线程，可以在emqx.ini配置文件中修改代理器等相关信息，启动该线程，可支持MQTT设备连接，并将消息转发至emqx服务器（阿里云、腾讯云、华为云都可以）。